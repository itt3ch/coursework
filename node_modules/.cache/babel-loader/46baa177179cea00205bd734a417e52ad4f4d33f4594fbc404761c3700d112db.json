{"ast":null,"code":"var _jsxFileName = \"d:\\\\coursework\\\\src\\\\components\\\\BSTVisualizer.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\nimport \"../styles/BSTVisualizer.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BSTVisualizer = ({\n  tree,\n  searchValue\n}) => {\n  _s();\n  const svgRef = useRef(); // Реф для SVG елемента\n  const width = 800;\n  const height = 400;\n  const [currentNode, setCurrentNode] = useState(null); // Для поточної вузла під час анімації\n\n  useEffect(() => {\n    const svg = d3.select(svgRef.current);\n    svg.selectAll(\"*\").remove(); // Очистка SVG перед ререндером\n\n    svg.attr(\"width\", width).attr(\"height\", height).style(\"background\", \"#f9f9f9\").style(\"border\", \"1px solid #ccc\");\n\n    // Рекурсивна функція для малювання дерева\n    const drawTree = (node, x, y, depth) => {\n      if (!node) return;\n      const offsetX = 300 / (depth + 1); // Горизонтальне зміщення залежно від глибини\n      const offsetY = 80; // Вертикальне зміщення між рівнями\n\n      // Малювання ліній до дочірніх вузлів\n      if (node.left) {\n        svg.append(\"line\").attr(\"x1\", x).attr(\"y1\", y).attr(\"x2\", x - offsetX).attr(\"y2\", y + offsetY).attr(\"stroke\", \"#00796b\").attr(\"stroke-width\", 2);\n        drawTree(node.left, x - offsetX, y + offsetY, depth + 1);\n      }\n      if (node.right) {\n        svg.append(\"line\").attr(\"x1\", x).attr(\"y1\", y).attr(\"x2\", x + offsetX).attr(\"y2\", y + offsetY).attr(\"stroke\", \"#00796b\").attr(\"stroke-width\", 2);\n        drawTree(node.right, x + offsetX, y + offsetY, depth + 1);\n      }\n\n      // Малювання вузлів\n      svg.append(\"circle\").attr(\"cx\", x).attr(\"cy\", y).attr(\"r\", 20).attr(\"fill\", node === currentNode ? \"#c0c0c0\" : \"#ffffff\") // Підсвічування поточного вузла\n      .attr(\"stroke\", \"#000\").attr(\"stroke-width\", 2);\n\n      // Додавання тексту у вузли\n      svg.append(\"text\").attr(\"x\", x).attr(\"y\", y + 5).attr(\"text-anchor\", \"middle\").attr(\"font-size\", \"12px\").attr(\"font-weight\", \"bold\").text(node.value);\n    };\n\n    // Малювання дерева\n    drawTree(tree, width / 2, 50, 1);\n  }, [tree, currentNode]); // Оновлюємо візуалізацію, коли змінюється дерево або поточний вузол\n\n  // Анімація пошуку\n  useEffect(() => {\n    if (!searchValue) return;\n    let node = tree; // Початковий вузол (корінь дерева)\n    const searchAnimation = setInterval(() => {\n      if (!node) {\n        clearInterval(searchAnimation);\n        return;\n      }\n      setCurrentNode(node); // Підсвічуємо поточний вузол\n\n      if (searchValue < node.value) {\n        node = node.left; // Йдемо вліво\n      } else if (searchValue > node.value) {\n        node = node.right; // Йдемо вправо\n      } else {\n        // Якщо знайдено вузол\n        clearInterval(searchAnimation);\n      }\n    }, 1000); // Інтервал між підсвічуваннями\n\n    return () => clearInterval(searchAnimation); // Очищення анімації при зміні значень\n  }, [searchValue, tree]);\n  return /*#__PURE__*/_jsxDEV(\"svg\", {\n    ref: svgRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 104,\n    columnNumber: 10\n  }, this);\n};\n_s(BSTVisualizer, \"VyPjFzIjBR+ullSz9NWvBCyfoFM=\");\n_c = BSTVisualizer;\nexport default BSTVisualizer;\nvar _c;\n$RefreshReg$(_c, \"BSTVisualizer\");","map":{"version":3,"names":["React","useEffect","useRef","useState","d3","jsxDEV","_jsxDEV","BSTVisualizer","tree","searchValue","_s","svgRef","width","height","currentNode","setCurrentNode","svg","select","current","selectAll","remove","attr","style","drawTree","node","x","y","depth","offsetX","offsetY","left","append","right","text","value","searchAnimation","setInterval","clearInterval","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["d:/coursework/src/components/BSTVisualizer.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport \"../styles/BSTVisualizer.css\";\r\n\r\nconst BSTVisualizer = ({ tree, searchValue }) => {\r\n  const svgRef = useRef(); // Реф для SVG елемента\r\n  const width = 800;\r\n  const height = 400;\r\n  const [currentNode, setCurrentNode] = useState(null); // Для поточної вузла під час анімації\r\n\r\n  useEffect(() => {\r\n    const svg = d3.select(svgRef.current);\r\n    svg.selectAll(\"*\").remove(); // Очистка SVG перед ререндером\r\n\r\n    svg\r\n      .attr(\"width\", width)\r\n      .attr(\"height\", height)\r\n      .style(\"background\", \"#f9f9f9\")\r\n      .style(\"border\", \"1px solid #ccc\");\r\n\r\n    // Рекурсивна функція для малювання дерева\r\n    const drawTree = (node, x, y, depth) => {\r\n      if (!node) return;\r\n\r\n      const offsetX = 300 / (depth + 1); // Горизонтальне зміщення залежно від глибини\r\n      const offsetY = 80; // Вертикальне зміщення між рівнями\r\n\r\n      // Малювання ліній до дочірніх вузлів\r\n      if (node.left) {\r\n        svg\r\n          .append(\"line\")\r\n          .attr(\"x1\", x)\r\n          .attr(\"y1\", y)\r\n          .attr(\"x2\", x - offsetX)\r\n          .attr(\"y2\", y + offsetY)\r\n          .attr(\"stroke\", \"#00796b\")\r\n          .attr(\"stroke-width\", 2);\r\n        drawTree(node.left, x - offsetX, y + offsetY, depth + 1);\r\n      }\r\n\r\n      if (node.right) {\r\n        svg\r\n          .append(\"line\")\r\n          .attr(\"x1\", x)\r\n          .attr(\"y1\", y)\r\n          .attr(\"x2\", x + offsetX)\r\n          .attr(\"y2\", y + offsetY)\r\n          .attr(\"stroke\", \"#00796b\")\r\n          .attr(\"stroke-width\", 2);\r\n        drawTree(node.right, x + offsetX, y + offsetY, depth + 1);\r\n      }\r\n\r\n      // Малювання вузлів\r\n      svg\r\n        .append(\"circle\")\r\n        .attr(\"cx\", x)\r\n        .attr(\"cy\", y)\r\n        .attr(\"r\", 20)\r\n        .attr(\"fill\", node === currentNode ? \"#c0c0c0\" : \"#ffffff\") // Підсвічування поточного вузла\r\n        .attr(\"stroke\", \"#000\")\r\n        .attr(\"stroke-width\", 2);\r\n\r\n      // Додавання тексту у вузли\r\n      svg\r\n        .append(\"text\")\r\n        .attr(\"x\", x)\r\n        .attr(\"y\", y + 5)\r\n        .attr(\"text-anchor\", \"middle\")\r\n        .attr(\"font-size\", \"12px\")\r\n        .attr(\"font-weight\", \"bold\")\r\n        .text(node.value);\r\n    };\r\n\r\n    // Малювання дерева\r\n    drawTree(tree, width / 2, 50, 1);\r\n  }, [tree, currentNode]); // Оновлюємо візуалізацію, коли змінюється дерево або поточний вузол\r\n\r\n  // Анімація пошуку\r\n  useEffect(() => {\r\n    if (!searchValue) return;\r\n\r\n    let node = tree; // Початковий вузол (корінь дерева)\r\n    const searchAnimation = setInterval(() => {\r\n      if (!node) {\r\n        clearInterval(searchAnimation);\r\n        return;\r\n      }\r\n\r\n      setCurrentNode(node); // Підсвічуємо поточний вузол\r\n\r\n      if (searchValue < node.value) {\r\n        node = node.left; // Йдемо вліво\r\n      } else if (searchValue > node.value) {\r\n        node = node.right; // Йдемо вправо\r\n      } else {\r\n        // Якщо знайдено вузол\r\n        clearInterval(searchAnimation);\r\n      }\r\n    }, 1000); // Інтервал між підсвічуваннями\r\n\r\n    return () => clearInterval(searchAnimation); // Очищення анімації при зміні значень\r\n  }, [searchValue, tree]);\r\n\r\n  return <svg ref={svgRef}></svg>;\r\n};\r\n\r\nexport default BSTVisualizer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}